pragma solidity ^0.4.24;

import "../ProduceAccessControl/FarmerRole.sol";
import "../ProduceAccessControl/RetailerRole.sol";
import "../ProduceAccessControl/ConsumerRole.sol";
import "../ProduceAccessControl/WholesalerRole.sol";
import "../Producecore/Ownable.sol";

// Define a contract 'Supplychain', inherent the relevant contracts
contract SupplyChain is FarmerRole, RetailerRole, ConsumerRole, WholesalerRole, Ownable {

  // Define 'owner'
  address owner;

  // Define a variable called 'upc' for Universal Product Code (UPC)
  uint  upc;

  // Define a variable called 'sku' for Stock Keeping Unit (SKU)
  uint  sku;

  // Define a public mapping 'items' that maps the UPC to an Item.
  mapping (uint => Item) items;

  // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash, 
  // that track its journey through the supply chain -- to be sent from DApp.
  mapping (uint => string[]) itemsHistory;

  // Define a mapping to map used upc 
  mapping(uint => bool) upcUsed;
  
  // Define enum 'State' with the following values:
  enum State 
  { 
    Harvested,  // 0
    WSold,  // 1
    WShipped,     // 2
    WReceived,    // 3
    Packaged,       // 4
    RSold,    // 5
    RShipped,   // 6
    RReceived,   // 7
    Sold         // 8
    }

  State constant defaultState = State.Harvested; //Default state = 0

  // Define a struct 'Item' with the following fields:
  struct Item {
    uint    sku;  // Stock Keeping Unit (SKU)
    uint    upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
    address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
    address originFarmerID; // Metamask-Ethereum address of the Farmer
    string  originFarmName; // Farmer Name
    string  originFarmInformation;  // Farmer Information
    string  productNotes; // Product Notes
    uint    productPrice; // Product Price
    State   itemState;  // Product State as represented in the enum above (in number)
    address wholesalerID;  // Metamask-Ethereum address of the Distributor
    address retailerID; // Metamask-Ethereum address of the Retailer
    address consumerID; // Metamask-Ethereum address of the Consumer
  }

  // Define 8 events with the same 8 state values and accept 'upc' as input argument
  event Harvested(uint upc);
  event WSold(uint upc);
  event WShipped(uint upc);
  event WReceived(uint upc);
  event Packaged(uint upc);
  event RSold(uint upc);
  event RShipped(uint upc);
  event RReceived(uint upc);
  event Sold(uint upc);

  // Define a modifier to allow only the item owner to perform certain action
  modifier onlyItemOwner(uint _upc){
    require(msg.sender == items[_upc].ownerID);
    _;
  }

  // Define a modifer that checks to see if msg.sender == owner of the contract
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address); 
    _;
  }
  
  // Define a modifier that checks the price and refunds the remaining balance
  modifier checkValue(uint _upc) {
    uint _price = items[_upc].productPrice;
    require(msg.value >= _price);
    _;     //If the condition is true, _; on the line beneath is where the function body is placed. In other words, the function will be executed.
    uint amountToReturn = msg.value - _price;
    msg.sender.transfer(amountToReturn); //depends on who is buying - need to modify Can we use msg.sender?
  }

  // Define a modifier that checks if an item.state of a upc is Harvested
  modifier harvested(uint _upc) {
    require(items[_upc].itemState == State.Harvested);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Sold to Wholesaler
  modifier wsold(uint _upc) {
    require(items[_upc].itemState == State.WSold);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Shipped to Wholesaler
  modifier wshipped(uint _upc) {
    require(items[_upc].itemState == State.WShipped);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Received by the Wholesaler
  modifier wreceived(uint _upc) {
    require(items[_upc].itemState == State.WReceived);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is packaged
  modifier packaged(uint _upc) {
    require(items[_upc].itemState == State.Packaged);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is sold to a retailer
  modifier rsold(uint _upc) {
    require(items[_upc].itemState == State.RSold);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is shipped to a retailer
  modifier rshipped(uint _upc) {
    require(items[_upc].itemState == State.RShipped);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is received by a retailer
  modifier rreceived(uint _upc) {
    require(items[_upc].itemState == State.RReceived);
    _;
  }

  modifier newitem (uint _upc) {
    require(upcUsed[_upc] == false);
    _;
  }

  // In the constructor set 'owner' to the address that instantiated the contract
  // and set 'sku' to 1
  // and set 'upc' to 1
  constructor() public payable {
    owner = msg.sender;
    sku = 1;
    upc = 1;
  }

  // return the latest skucount
  function checksku() public view returns (uint){
    return sku;
  }
  
  // Define a function 'kill' if required
  function kill() public {
    if (msg.sender == owner) {
      selfdestruct(owner);  //sends all of the contract's current balance to address
    }
  }

  // Define a function 'harvestItem' that allows a farmer to mark an item 'Harvested'
  function harvestItem(uint _upc, string _originFarmName, string _originFarmInformation, string  _productNotes, uint _productPrice) onlyFarmer() newitem (_upc) public 
  {
    // Add the new item as part of Harvest
    items[_upc] = Item({sku: sku, upc: _upc, ownerID: msg.sender, originFarmerID: msg.sender, originFarmName: _originFarmName, originFarmInformation: _originFarmInformation, productNotes: _productNotes, productPrice: _productPrice, itemState: State.Harvested, wholesalerID: address(0), retailerID: address(0), consumerID: address(0)});
    // Increase sku
    sku = sku + 1;
    // Emit the appropriate event
    emit Harvested(_upc);
    //mark upc as used
    upcUsed[_upc] = true;
    
  }

  //allow a wholesaler to buy an item from a farmer
  function BuyWhole(uint _upc) onlyWholesaler() harvested(_upc) checkValue(_upc) public payable {
    address buyer = msg.sender;
    uint price = items[_upc].productPrice;
    items[_upc].originFarmerID.transfer(price);
    items[_upc].ownerID = buyer;
    items[_upc].wholesalerID = buyer;
    items[_upc].itemState = State.WSold;
    emit WSold (_upc);
  }

  //allow the original farmer to set the sold product's status as shipped
  function ShippedWhole(uint _upc) wsold(_upc) verifyCaller (items[_upc].originFarmerID) public {
    items[_upc].itemState = State.WShipped;
    emit WShipped(_upc);
  }

  //allow the wholesaler to mark an item as received 
  function WholeReceived (uint _upc) wshipped(_upc) onlyItemOwner (_upc) public {
    items[_upc].itemState = State.WReceived;
    emit WReceived(_upc);
  }

  //allow wholesaler to mark the item as packaged and set the price
  function isPackaged (uint _upc, uint _price) wreceived(_upc) onlyItemOwner (_upc) public {
    items[_upc].productPrice = _price;
    items[_upc].itemState = State.Packaged;
    emit Packaged(_upc);
  }

  //allow retailer to buy an item
  function BuyRe (uint _upc) onlyRetailer() packaged(_upc) checkValue(_upc) public payable {
    address buyer = msg.sender;
    uint price = items[_upc].productPrice;
    items[_upc].wholesalerID.transfer(price);
    items[_upc].ownerID = buyer;
    items[_upc].retailerID = buyer;
    items[_upc].itemState = State.RSold;
    emit RSold (_upc);
  }   

  //allow wholesaler to change the status of an item to shipped
  function ShippedRe(uint _upc) rsold(_upc) verifyCaller (items[_upc].wholesalerID) public {
    items[_upc].itemState = State.RShipped;
    emit RShipped(_upc);
  }

  //allow a retailer to mark the item as received and set the price of the item
  function ReReceived (uint _upc, uint _price) rshipped(_upc) onlyItemOwner (_upc) public {
    items[_upc].productPrice = _price;
    items[_upc].itemState = State.RReceived;
    emit RReceived(_upc);
  }

  //allow consumer to mark an item as bought
  function Buy (uint _upc) onlyConsumer() rreceived(_upc) checkValue(_upc) public payable {
    address buyer = msg.sender;
    uint price = items[_upc].productPrice;
    items[_upc].retailerID.transfer(price);
    items[_upc].ownerID = buyer;
    items[_upc].consumerID = buyer;
    items[_upc].itemState = State.Sold;
    emit Sold (_upc);
  }

  //allow item owner to set price of the item
  function SetPrice (uint _upc, uint _price) onlyItemOwner (_upc) public {
    items[_upc].productPrice = _price;  
  }

  // Define a function 'fetchItemFarmer' that fetches the basic farmer and farm data
  function fetchItemFarmer(uint _upc) public view returns (uint, uint, address, address, string, string, string){
    return (items[_upc].sku, items[_upc].upc, items[_upc].ownerID, items[_upc].originFarmerID, items[_upc].originFarmName, items[_upc].originFarmInformation, items[_upc].productNotes);
  }

  // Define a function 'fetchItemLogistics' that fetches the logistical data
  function fetchItemLogistics(uint _upc) public view returns (uint, uint, uint, State, address, address, address, address){
    Item memory i = items[_upc];//stack too long, need to shorten by this method
    return (i.sku, i.upc, i.productPrice, i.itemState, i.originFarmerID, i.wholesalerID, i.retailerID, i.consumerID);
  }

}

